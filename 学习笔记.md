# NodeJs学习笔记

## node核心

### 浏览器中的js

+ web api + EcmaScript(js语言标准 + WebApi)

+ web api提供操作浏览器窗口和页面的能力(bom, dom, ajax)
+ 这种能力是非常有限的, 如跨域问题、文件读写

### node中的js

+ 提供了几乎所有能做的事
+ ScmaScript + Node Api

### Node能干什么

+ 开发桌面应用程序
+ 开发服务器应用程序
  + 通常应用在微型的站点上<img src="C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241104103153668.png" alt="image-20241104103153668" style="zoom:67%;" />
  + 用作请求转发，充当前台的作用<img src="C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241104103653631.png" alt="image-20241104103653631" style="zoom:67%;" />
    1. 简单的信息记录
    2. 静态资源托管
    3. 缓存

### 全局对象

1. setTimeout
2. setInterval
3. setImmediate, 类似setTimeout 0
4. console
5. __dirname: 获取当前模块所在目录，非global属性
6. __filename：获取当前模块所在的文件路径，非global属性
7. Buffer：类型化数组
8. process进程
   1. ==cwd(): 它返回的是一个字符串，表示运行 Node.js 进程时的工作目录（当前工作的命令行打开的路径)==
   2. exit(): 强制退出当前node进程，可传入退出码，0表示成功退出，默认为0
   3. argv： String[] 获取命令中所有的参数
   4. platform() : 获取当前操作系统
   5. kill(pid): 结束指定pid进程
   6. ==env: 获取操作系统环境变量==

### 模块化细节

#### 模块的查找

+ 绝对路径
+ 相对路径 ./ 或 ../, 最终都会转成绝对路径
+ 相对路径无./ ../
  + 检查是否是内置模块，如fs，path等
  + 检查当前目录中的node_modules
  + 检查上级目录中的node_modules
  + 转化为绝对路径
  + 加载模块
+ 关于后缀名
  + 如果不提供后缀名，自动补全
  + js，json，node，mjs
+ 关于文件名
  + 如果只提供目录，不提供文件名，则自动寻找目录中的index.js
  + package.json中的main字段

#### modules对象

记录当前模块信息

<img src="C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241104114436264.png" alt="image-20241104114436264" style="zoom:67%;" />

#### require函数

执行原理：

```javascript
function require(modulePath) {
    // 1. 吧modulePath解析成绝对路径
    // 2. 判断是否在缓存中
    // 3. 如果在缓存中，直接返回缓存中的模块

    // 4. 如果不在缓存中，加载模块
    // 将模块中的内容包裹在一个函数中
    function __temp(module, exports,require, __dirname, __filename) {
        console.log("当前模块路径： ", __dirname);
        console.log("当前模块文件名： ", __filename);

        exports.c = 3;
        module.exports = {
            a: 1,
            b: 2,
        };
        this.m = 5

        return module.exports
    }
    // 5. 创建module对象
    module.exports = {}
    const exports = module.exports
    __temp.call(module.exports, module, exports, require, module.path, module.filename)
    // 6. 执行函数内容，返回模块的exports对象
}
```

总结：

1. eslint语法不允许在模块内重新赋值exports变量，因此可以把this等同于exports

2. 加载模块时，返回的对象是module.exports，因此如果给module.exports赋值为一个新的对象，require的结果会变成新的对象

   ```js
   const res = require("./src");
   console.log(res); // { a: 1, b: 2 }
   
   // 还是原来的module.exports
   console.log(this)// { c: 3 }
   console.log(this === module.exports) // false
   ```

### Node中的ES模块化

模块要么是commonjs要么是Es

+ commonjs：默认情况下，都是commonjs
+ 最近的package.json中的type值是module

> 当使用ES模块化时，必须添加experimental-modules标记

### 基本内置模块

nodejs是跨平台的

#### os

1. EOL: 一行结束的分隔符，换行符
2. arch()： 获取cpu的架构名
3. ==cpus==()：获取cpu每个核的信息
4. freemem(): 获取当前可用内存（单位：字节）
5. homedir(): 用户目录
6. hostname(): 获取主机名
7. ==tmpdir==(): 操作系统的临时目录

#### path

https://nodejs.org/docs/latest/api/path.html

1. baseName： 获取路径的的文件名（不会检查路径是否存在，相当于字符串的处理）

2. delimiter： 分隔符<img src="C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241104231332733.png" alt="image-20241104231332733" style="zoom:67%;" />

   window下为`；`

   seq也是分隔符，不过是在更具体一点，windows为`\`

3. extname: 获取路径的后缀名，同baseName

4. join

5. normalize

6. relative

7. resolve

#### url

https://nodejs.org/docs/latest/api/url.html

#### util

https://nodejs.org/docs/latest/api/util.html

1. callbackify(orginal : function): 将异步函数转换为回调函数

   ```js
   const util = require('util');
   
   async function delay(duration = 1000){
       return new Promise((resolve) =>{
           setTimeout(() => {
               resolve(duration)
           }, duration);   
       }) 
   }
   
   delay(1000).then(result => {
       console.log(`delay-promise: Waited for ${result}ms`);
   })
   
   const delayCallback = util.callbackify(delay)
   delayCallback(3 * 1000, (err, result) => {
       console.log(`delay-callback: Waited for ${result}ms`);
   })
   ```

   

2. ###### ==promisify(original: function): callbackify的逆过程==

   ```js
   // 延迟durations毫秒后调用callback函数
   const delayCallback = (duration, callback) =>{
       setTimeout(() =>{
           callback(null, duration)
       }, duration)
   }
   
   const delayPromise = util.promisify(delayCallback)
   
   delayPromise(1000).then(result => {
       console.log(`delay-promise: Waited for ${result}ms`);
   })
   
   
   ```

   将回调模式转换成promise模式，可以通过await async来控制，更加方便

   ```js
   const duration = await delayPromise(1000)
   console.log(`delay-promise: Waited for ${duration}ms`);
   ```

3. isDeepStrictEqual(val1, val2): 深度严格比较两个对象

### 文件I/O

1. 一般指定文件路径使用绝对路径，使用相对路径容易出问题

   > 除了require导入模块相对的是当前模块，其他的相对路径都是相对于当前工作的命令行，如readFile, 使用相对路径==当命令行路径变化时，可能出现异常==，一般使用__dirname获取当前模块所在的目录

2. fs模块的函数一般默认都是异步的，但是也提供了同步函数，如readFile的同步版readFileSync，同步函数会导致代码运行阻塞，影响性能，通常只在程序启动时运行有限次数即可。

3. ==api默认是回调写法，但是也有promise写法==

   ```js
   // 回调写法
   fs.readFile(fileName, {encoding: 'utf-8'}, (err, data) => {
       console.log(data.toString())
   })
   
   // promise写法
   fs.promises.readFile(fileName, {encoding: 'utf-8'}).then(data => {
       console.log(data.toString())
   }).catch(err => {
       console.log(err)
   })
   ```

4. 文件流

   > 流是指数据的流动，流是有方向的，js中流分为
   >
   > 可读流Readable：数据从源头流向内存
   >
   > 可写流Writable：数据从内存流向源头
   >
   > 双工流：数据既能从源头流向内存也能从内存流向源头

   > 使用readFile，writeFile操作文件会极大地占用内存， 并且内存的数据处理能力远高于外存

   + 可读流
     ```js
     const fs = require('fs')
     const path = require('path')
     
     const fileName = path.resolve(__dirname, '../myFiles/1.txt')
     
     // 创建一个读取流，是可读流Readable的子类
     // function createWriteStream(path: fs.PathLike, options?: BufferEncoding | WriteStreamOptions): fs.WriteStream
     const readStream = fs.createReadStream(fileName, {
         encoding: 'utf-8',
         highWaterMark: 1, // 每次读取的块大小,若不设置encoding，则表示一个字节，若设置了，则表示一个字符
         autoClose: true // 读取完毕后自动关闭文件
     })
     
     // rs.on('事件名', 回调函数)
     // open: 文件打开事件，文件打开后被触发
     // error: 文件打开失败后被触发
     // data: 读取到数据后被触发,只有当设置了data事件后，才会真正开始读取
     // end: 读取完毕后被触发
     // close: 文件关闭后被触发
     
     // 这里每次读一个字符，因为设置了hignWaterMark和encoding
     readStream.on('data', (chunk) => { 
         console.log('读取到部分数据：', chunk)
     })  
     
     readStream.on('end', () =>{
         console.log('文件读完了...')
     })
      
     readStream.on('close', () =>{
         console.log('文件流关闭...')
     })
     ```

     rs.pause(): 暂停读取，会触发pause事件

     rs.resume(): 恢复读取，会触发resume事件

   + 可写流

     ```js
     const fs = require('fs')
     const path = require('path')
     
     const fileName = path.resolve(__dirname, '../myFiles/2.txt')
     
     // function createWriteStream(path: fs.PathLike, 
     // options?: BufferEncoding | WriteStreamOptions): fs.WriteStream
     // options: 
     // encoding: 编码格式
     // flags: 文件打开模式 w：覆盖写入，a：追加写入
     // autoClose: 写入完毕后是否自动关闭文件
     // start: 起始字节
     // highWaterMark: 每次写入的块字节数
     
     const writeStream = fs.createWriteStream(fileName, {
         encoding: 'utf-8',
         flags: 'a', // 追加写入
         highWaterMark: 2 // 每次写入的块字节数, 默认是16 * 1024
     })
     
     // ws.on('事件名', 处理函数)
     // open： 文件打开事件
     // error： 打开文件出错事件
     // close： 文件关闭事件
     // drain： 当写入缓存区为空时，触发drain事件
     // finish： 写入完毕后触发
     
     // writable.write()方法会向数据流写入一些数据，
     // 并在数据完全处理完毕后调用提供的回调。
     // 如果发生错误，将以错误作为第一个参数调用回调。
     // 回调会在发出 "error "之前异步调用。
     
     // 如果内部缓冲区小于创建流时配置的 highWaterMark，则返回值为 true。
     // 如果返回值为 false，则应停止向流写入数据的进一步尝试，直到 "drain"事件发生。
     const flag = writeStream.write('哈哈', () =>{
         console.log('写入成功')
     })
     
     // 当写入缓存区为空时，触发drain事件
     writeStream.on('drain', () =>{
         console.log('缓存区为空，可以继续写入')
     })
     
     console.log(flag) 
     
     // ws.end([data])
     // 结束写入，默认自动关闭文件，看的是流的autoClose字段
     // 如果提供data，则相当于调用write(data)，然后end()
     ```

     > ==上面的写方式会产生背压问题==，它一次性将所有要写的内容都放到了内存中，需要的缓冲区会很大，如果不解决这个问题，那这和writeFile就没什么区别。

     因此，当write返回false时，表示缓冲区大小和流的大小相等，此时应该停止写入，等待缓冲区清空，触发drain事件，再继续写

     ==然而，这个过程其实也是流的api==，不然为什么要有它呢哈哈哈
     ==readStream.pipe(writeStream): writeStream 它将可读流连接到可写流，解决了背压问题==

### net模块(TCP/IP传输层)

net是一个通信模块，利用它可以

进程的通信 IPC、==网络通信TCP/IP==

创建client：

```js
const net = require('net');

// socket是一个特殊的流对象
// 在node中表现未一个双工流对象
// 通过向流写入内容发送数据
// 通过监听流的内容获取数据
// tcp协议
const socket = net.createConnection({
    host: '127.0.0.1',
    port: 3001
}, () => {
    console.log('连接成功');
})


socket.on("data", chunk => {
    // console.log('服务器说:', chunk.toString("utf-8"));
    // socket.end();
    parseResponse(chunk.toString("utf-8"));
})

socket.on("close", () => {
    console.log('连接关闭');
})

// 修正HTTP请求格式
socket.write(`GET / HTTP/1.1\r\n\
Host: 127.0.0.1:3001\r\n\
Connection: keep-alive\r\n\
\r\n`); 

/**
 * 提炼出响应字符串的消息头和消息体
 */
function parseResponse(response) {
    const index = response.indexOf('\r\n\r\n');
    const responseHeaders = response.substring(0, index + 2);
    const responseBody = response.substring(index + 2);
    console.log('响应头:', responseHeaders);
    console.log('响应体:', responseBody);
}

```

创建server：

```js
const net = require('net');

const server = net.createServer()

server.listen(3002, () =>{
    console.log('server listen 3002')
})

server.on('connection', socket => {
    console.log('有新的连接')
    socket.on('data', chunk => {
        console.log('客户端说:', chunk.toString('utf-8'))

        socket.write('收到了')
        socket.end()
    })

    socket.on('close', () => {
        console.log('连接关闭')
    })
})
```

### http模块(应用层)

> http模块建立在net模块之上，无需手动管理socket，无需手动组装消息格式

+ `http.request(url[,options][,callback])`

  ```js
  const http = require('http');
  
  // 可写流
  // ClientRequest对象
  const req = http.request("http://127.0.0.1:3002/", 
      {method: 'POST'},
      res => {
      console.log('响应状态码:', res.statusCode)
      console.log('响应头:', res.headers)
      res.on('data', chunk => {
          // console.log('响应体:', chunk)
          console.log('响应体:', chunk.toString('utf-8'))
      })
  
      res.on('end', () => {
          console.log('响应结束')
      })
  })
  
  req.write('请求消息体内容...')
  req.end() // 发送消息体，表示消息体结束
  ```

  

+ `http.createServer([options][,requestListener])`

  ```js
  const http = require('http');
  
  const server = http.createServer((req, res) =>{
      console.log('请求来了')
      console.log('请求路径:', req.url)
      console.log('请求头:', req.headers)
      let body = ''
      req.on('data', chunk => {
          body += chunk.toString('utf-8')
      })
  
      req.on('end', () => {
          console.log('请求体:', body)
      })
  
      res.setHeader('a', '1')
      res.setHeader('b', '2')
  
      res.write('你好')
      res.end()
  
  })
  
  server.listen(3002, () => {
      console.log('server listen 3002')
  })
  
  server.on('connection', socket => {
      console.log('有新的连接')
  })
  
  ```

### 简易的静态服务器

```js
// 静态服务器
const http = require('http')
const URL = require('url')
const fs = require('fs')
const path = require('path')

/**
 * 获取文件内容
 * @param {*} url url路径
 * @returns 文件内容
 */
const getFileContent = async (url) =>{
    const urlObj = URL.parse(url, true)
    const filePath = urlObj.pathname
    // console.log(filePath)
    // console.log(__dirname)
    // url路径的第一个/要去掉
    let fileName = path.resolve(__dirname, '../public', filePath.substring(1))
    // console.log(fileName)

    // console.log(fs.existsSync(fileName))
    if(!fs.existsSync(fileName)){
        // 文件或目录不存在
        console.log('文件不存在')
        return null;
    }else if(fs.statSync(fileName).isDirectory()){
        // 是目录
        // 默认访问index.html
        fileName = path.resolve(__dirname, '../public', filePath.substring(1), 'index.html')
        // console.log(fileName)

        // 如果index.html文件不存在
        if(!fs.existsSync(fileName)){
            console.log(fileName + ' 文件不存在')
            return null;
        }else{
            console.log(fileName + ' 文件存在')

            return await fs.promises.readFile(fileName)
        }
    }else{
        // 正常的文件
        console.log(fileName + ' 正常的文件')

        return await fs.promises.readFile(fileName)
    }

    // return fileName
}
// 创建server
const server = http.createServer(async (req, resp) => {
    // 获取请求路径
    const url = req.url
    // 获取文件信息
    const fileContent = await getFileContent(url)

    if(fileContent){
        resp.write(fileContent)
    }else{
        resp.statusCode = 404
        resp.write('Resource not found')
    }
    resp.end()
})

server.listen(3003, () => {
    console.log('server listen 3003')
})

```

### https协议

> https保证数据在传输过程中不被篡改和窃取

对传输的数据进行加密

1. 对称加密，

   加密：info + key --> 传输
   解密：传输数据 + key --> info
   DES，3DES，AES等

   风险：如果被窃取密钥，数据同样不安全

2. 非对称加密：

   > 产生一对密钥，一个用于加密，一个用于解密
   >
   > 密钥对： 公钥 + 私钥
   >
   > 加密过程：信息 + 公钥 = 传输数据
   >
   > 解密过程： 传输数据 + 私钥 = 信息

   常用算法: RSA

   传输方案：A与B通信，一方持有私钥key1，双方都共享公钥key1，

   无私钥的一方再通过公钥key1给私钥方发送公钥key2，此时的公钥key2就是安全的。后续的通信就使用key2进行。==但是仍然不能防止密钥被篡改的问题。==

   ![image-20241120163225224](C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241120163225224.png)

3. 此时就需要一个证书颁发机构

   ![image-20241120163524356](C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241120163524356.png)

   证书Digital Certificate(DC)

   ![image-20241120163827625](C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241120163827625.png)

   ![image-20241120163845369](C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241120163845369.png)

   如果另一方计算签名后，签名不一致，则公钥key1不一样，就证明被篡改了。因为key1只能读不能改，私钥在机构那里。 

### https模块

### EventEmitter

> nodejs中事件管理的通用机制

## 数据驱动和ORM

### 数据驱动mysql2

1. npm install --save mysql2

2. 相当于jdbc

   ```js
   const mysql = require('mysql2/promise');
   
   // 数据库配置
   const dbConfig = {
       host: 'localhost',
       port: 3306,
       user: 'root',
       password: 'root',
       database: 'learning-nodejs-mysql2'
   };
   
   const pool = mysql.createPool({
       host: 'localhost',
       port: 3306,
       user: 'root',
       password: 'root',
       database: 'learning-nodejs-mysql2',
       waitForConnections: true,
       connectionLimit: 10,
       maxIdle: 10, // max idle connections, the default value is the same as `connectionLimit`
       idleTimeout: 60000, // idle connections timeout, in milliseconds, the default value 60000
       queueLimit: 0,
       enableKeepAlive: true,
       keepAliveInitialDelay: 0,
     });
   
   // console.log(pool)
   
   async function test() {
       const [rows] = await pool.execute('SELECT * FROM t_user')
       console.log(rows)
       await pool.end()
   }
   
   test()
   ```

### ORM(对象关系映射)

> 1. 通过ORM框架，可以自动吧程序中的对象和数据库关联
>
> 2. ORM框架隐藏具体的数据库底层细节，让开发者使用同样的数据库操作接口，完成对不同的数据库的操作
> 3. 可轻易地完成数据库的迁移，不需要修改程序代码

### node中的ORM

#### Sequelize(成熟)(JS、TS)

1. 安装数据库驱动mysql2依赖
2. 安装sequelize依赖
3. 测试

#### TypeORM(TS)

## Web框架

> [express](https://expressjs.com/zh-cn/)、koa2

### express入门

1. 安装express

   ` npm install express --save`

2. 创建web服务器

   ```js
    const express = require('express');
   //  const http = require('http');
    // 创建web服务器
    // app实际上是一个函数，用于处理请求的函数
    const app = express();
   
   //  const server = http.createServer(app);
   
    app.listen(3000, () => {
       console.log('server listen 3000')
    })
   
    // 请求路径映射
    // app.请求方法(路径, 回调函数)
    app.get('/:id', (req, resp) => {
       console.log('请求头:', req.headers)
       console.log('请求路径:', req.url)
       console.log('请求参数: ', req.query)
       // 通过params获取路径变量
       console.log('路径变量:', req.params)
       resp.send('hello world')
    })
   
    app.post('/', (req, resp) => {
       resp.send('post hello world')
    })
   ```

### 中间件

![image-20241122134853816](C:\Users\28307\AppData\Roaming\Typora\typora-user-images\image-20241122134853816.png)

当匹配到请求后，会交给第一个处理函数处理，函数需要显式调用next()函数交给下一个处理函数

#### 处理细节：

```js
 app.get('/test', (req, resp, next) => {
    console.log('handler 1') 
    resp.send('handler 1')
    //resp.setHeader('a', 'b') 报错
    next()
    resp.end()
    console.log('handler 1 end')
 }, (req, resp) =>{
    console.log('handler 2')
    // 第二次调用send,setHeader会报错，因为send中会自动调用end函数
    // resp.send('handler 2')
   //  resp.setHeader('a', 'b')
    console.log('handler 2 end')
 })
```

+ resp.send() 会自动调用 resp.end()，调用了end后，无法再对resp对象进行操作

+ 在第一个处理函数中，resp.send() 后继续调用 next() 是没有意义的，因为响应已经结束
+ 如果处理执行力链都没有完成处理（resp.end没有被调用），express发现响应没有结束，会响应404
+ 如果中间件发生错误 `throw new Error('handler 1 error')`，不会停止整个服务器，`  // 相当于next(new Error('handler 1 error'))`， 寻找后续的错误处理中间件，如果没有错误处理中间件，则响应500

最佳实践： 

+ 在中间件链中，只在最后一个处理函数中发送响应
+ 调用 next() 之后就不应该再对响应进行操作（这里resp.end()之后还能打印是因为next()是异步函数

#### 使用app.use注册中间件

```js
 // 匹配任何请求
app.use(require('./exceptionHandler'))
// 前缀匹配模式
// 能匹配/news, /news/abc, /news/abc/123
// 不能匹配/new...
app.use("/news",require('./exceptionHandler'))
```

==注意： 异常处理中间件需要放在所有请求之后，Express 按照中间件定义的顺序依次执行==

#### 常用中间件

+ express.static: 静态资源处理中间件
+ express.json: 解析请求体的内容为对象，通过req.body获取

#### 路由

路由其实也是一个中间件，通过app.use设置路由的基础url, url匹配成功后即进入该路由

`app.use('/api/stu', require('./studentController'))`

> 使用 `express.Router` 类来创建可安装的模块化路由处理程序。`Router` 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。

```js
const express = require('express')

const studentRouter = express.Router()

studentRouter.get('/', async (req, resp) => {
    // resp.send('分页获取学生列表')
    const studentService = require('../service/studentService')
    const studentList = await studentService.getStudentList()
    console.log(studentList)
    resp.send(studentList)
 })

studentRouter.get('/:id', (req, resp) => {
    resp.send('get student by id:' + req.params.id)
})

studentRouter.post('/', (req, resp) => {
    // console.log('请求体:', req.body)
    // resp.send(req.body)
    resp.send('添加一个学生')
})

studentRouter.put('/:id', (req, resp) => {
    resp.send('更新一个学生id=' + req.params.id)
})

studentRouter.delete('/:id', (req, resp) => {
    resp.send('删除一个学生id=' + req.params.id)
})

studentRouter.get('/test/123', (req, resp) => {
    resp.send('test')
})
module.exports = studentRouter
```

### cookie实现登录及验证

1. 安装express cookie中间件[cookie-parse](https://www.expressjs.com.cn/resources/middleware/cookie-parser.html)
   ```bash
   npm install cookie-parse --save
   ```

2. 导入中间件，在express实例中使用，==为了防止伪造cookie，可以传入一个对称加密密钥==

   ```js
   var express = require('express')
   var cookieParser = require('cookie-parser')
   
   var app = express()
   // mwj是密钥，采用对称加密
   app.use(cookieParser("mwj"))
   
   app.get('/', function (req, res) {
     // Cookies that have not been signed
     console.log('Cookies: ', req.cookies)
   
     // Cookies that have been signed
     console.log('Signed Cookies: ', req.signedCookies)
   })
   
   app.listen(8080)
   
   // curl command that sends an HTTP request with two cookies
   // curl http://127.0.0.1:8080 --cookie "Cho=Kim;Greet=Hello"
   ```

3. 登录成功后给予token

   + 通过cookie给予：适配浏览器

     ```js
     const express = require('express')
     
     const userRouter = express.Router()
     
     userRouter.post('/login', (req, resp) => {
         const {username, password} = req.body
         if(username === 'admin' && password === 'admin'){
             //登录成功
             const id = '007'
             // 设置cookie
             resp.cookie('id', id, {
                 maxAge: 1000 * 60 * 60 * 1,
                 signed: true // 加密cookie的value
             })
             resp.send('登录成功')
         }else{
             resp.send('登录失败')
         }
     })
     
     module.exports = userRouter
     ```

   + 通过header给予：适配其他终端，一般为Authorization

4. 对后续请求进行认证

   + 解析cookie或header中的id
   + 验证token: 通过 --> 继续后续处理，未通过：给予错误

### 跨域

> 同源策略：在浏览器中，当前页面与请求路径地址不同源时，会阻止这类请求
>
> 同源要求：协议、域名、端口都必须一致

#### 跨域之JSONP

1. 浏览器端生成一个script元素，访问数据接口
2. 服务器响应一段js代码，调用某个函数，并把响应的数据传入

缺陷: 影响服务器的正常响应数据格式，且只能使用get请求

#### 跨域之CORS(Cross-Origin-Resource-Sharing)

总体思路：如果浏览器需要跨域访问服务器的资源，需要获得服务器的允许

针对不同的请求，CORS规定了三种不同的交互模式：

##### 简单请求

###### 判定方式

当请求**同时满足**以下条件时，浏览器会认为它是一个简单请求：

1. 请求方法属于下面的一种：
   + get
   + post
   + head
2. 请求头仅包含安全的字段，常见的安全字段如下：
   - `Accept`
   - `Accept-Language`
   - `Content-Language`
   - `Content-Type`
   - `DPR`
   - `Downlink`
   - `Save-Data`
   - `Viewport-Width`
   - `Width`
3. 请求头如果包含`Content-Type`，仅限下面的值之一：
   - `text/plain`
   - `multipart/form-data`
   - `application/x-www-form-urlencoded`

如果以上三个条件同时满足，浏览器判定为简单请求。

下面是一些例子：

```js
// 简单请求
fetch("http://crossdomain.com/api/news");

// 请求方法不满足要求，不是简单请求
fetch("http://crossdomain.com/api/news", {
  method:"PUT"
})

// 加入了额外的请求头，不是简单请求
fetch("http://crossdomain.com/api/news", {
  headers:{
    a: 1
  }
})

// 简单请求
fetch("http://crossdomain.com/api/news", {
  method: "post"
})

// content-type不满足要求，不是简单请求
fetch("http://crossdomain.com/api/news", {
  method: "post",
  headers: {
    "content-type": "application/json"
  }
})
```

###### 交互规范

当浏览器判定某个**ajax跨域请求**是**简单请求**时，会发生以下的事情：

1. ==**请求头中会自动添加`Origin`字段**==

   比如，在页面`http://my.com/index.html`中有以下代码造成了跨域
   ```js
   // 简单请求
   fetch("http://crossdomain.com/api/news");
   ```

   请求发出后，请求头会是下面的格式：

   ```js
   GET /api/news/ HTTP/1.1
   Host: crossdomain.com
   Connection: keep-alive
   ...
   Referer: http://my.com/index.html
   Origin: http://my.com
   ```

   看到最后一行没，`Origin`字段会告诉服务器，是哪个源地址在跨域请求

2. **服务器响应头中应包含`Access-Control-Allow-Origin`**

当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加`Access-Control-Allow-Origin`字段

该字段的值可以是：

- *：表示我很开放，什么人我都允许访问
- 具体的源：比如`http://my.com`，表示我就允许你访问

> 实际上，这两个值对于客户端`http://my.com`而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许
>
> 当然，服务器也可以维护一个可被允许的源列表，如果请求的`Origin`命中该列表，才响应`*`或具体的源
>
> **为了避免后续的麻烦，强烈推荐响应具体的源**

假设服务器做出了以下的响应：

```
HTTP/1.1 200 OK
Date: Tue, 21 Apr 2020 08:03:35 GMT
...
Access-Control-Allow-Origin: http://my.com
...

消息体中的数据
```

当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js，以完成后续的操作

下图简述了整个交互过程

![image-20241125225713601](C:\Users\28307\Pictures\Mark Text image\image-20241125225713601.png)

##### 预检请求

简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。

但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：

1. **浏览器发送预检请求，询问服务器是否允许**
2. **服务器允许**
3. **浏览器发送真实请求**
4. **服务器完成真实的响应**

比如，在页面`http://my.com/index.html`中有以下代码造成了跨域

```js
// 需要预检的请求
fetch("http://crossdomain.com/api/user", {
  method:"POST", // post 请求
  headers:{  // 设置请求头
    a: 1,
    b: 2,
    "content-type": "application/json"
  },
  body: JSON.stringify({ name: "袁小进", age: 18 }) // 设置请求体
});
```

浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互

1. **浏览器发送预检请求，询问服务器是否允许**

```js
OPTIONS /api/user HTTP/1.1
Host: crossdomain.com
...
Origin: http://my.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: a, b, content-type
```

可以看出，这并非我们想要发出的真实请求，请求中不包含我们的响应头，也没有消息体。

这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。

预检请求**没有请求体**，它包含了后续真实请求要做的事情

预检请求有以下特征：

- 请求方法为`OPTIONS`
- 没有请求体
- 请求头中包含
  - `Origin`：请求的源，和简单请求的含义一致
  - `Access-Control-Request-Method`：后续的真实请求将使用的请求方法
  - `Access-Control-Request-Headers`：后续的真实请求会改动的请求头

2. **服务器允许**

服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式

```
HTTP/1.1 200 OK
Date: Tue, 21 Apr 2020 08:03:35 GMT
...
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST
Access-Control-Allow-Headers: a, b, content-type
Access-Control-Max-Age: 86400
...
```

对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：

- `Access-Control-Allow-Origin`：和简单请求一样，表示允许的源
- `Access-Control-Allow-Methods`：表示允许的后续真实的请求方法
- `Access-Control-Allow-Headers`：表示允许改动的请求头
- `Access-Control-Max-Age`：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了

3. **浏览器发送真实请求**

预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据

```
POST /api/user HTTP/1.1
Host: crossdomain.com
Connection: keep-alive
...
Referer: http://my.com/index.html
Origin: http://my.com

{"name": "袁小进", "age": 18 }
```

4. **服务器响应真实请求**

```
HTTP/1.1 200 OK
Date: Tue, 21 Apr 2020 08:03:35 GMT
...
Access-Control-Allow-Origin: http://my.com
...

添加用户成功
```



可以看出，当完成预检之后，后续的处理与简单请求相同

下图简述了整个交互过程

![image-20241125230210531](C:\Users\28307\Pictures\Mark Text image\image-20241125230210531.png)

##### 附带身份的请求

默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行

不过可以通过简单的配置就可以实现附带cookie

```js
// xhr
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;

// fetch api
fetch(url, {
  credentials: "include"
})
```

这样一来，该跨域的ajax请求就是一个*附带身份凭证的请求*

当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加`cookie`字段

而服务器响应时，需要明确告知客户端：服务器允许这样的凭据

告知的方式也非常的简单，只需要在响应头中添加：`Access-Control-Allow-Credentials: true`即可

对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。

另外要特别注意的是：==**对于附带身份凭证的请求，服务器不得设置 `Access-Control-Allow-Origin 的值为*`**==。这就是为什么不推荐使用*的原因

##### 一个额外的补充

在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。

`Access-Control-Expose-Headers`头让服务器把允许浏览器访问的头放入白名单，例如：

```
Access-Control-Expose-Headers: authorization, a, b
```

这样JS就能够访问指定的响应头了。

##### 跨域中间件

> 为了解决上述跨域问题，就需要手动判断请求是简单请求还是预检请求，并且要根据请求的类型设置正确的响应头，非常地麻烦。
>
> 由于这些操作也是对req，resp进行操作，因此肯定有中间件

[cors源码](https://github.com/expressjs/cors)

注：默认不允许发送cookie，需手动设置

### cookie

优点：存储在客户端，不占用服务器资源

缺点：

+ ==只能是字符串格式==
+ 存储量有限(4KB)
+ 数据容易被获取
+ 数据容易被篡改
+ 容易丢失

### session

优点：存储在服务端

+ ==可以是任何格式==
+ 存储量理论上是无限
+ 数据难以被获取
+ 数据难以篡改
+ 不易丢失

缺点：占用服务器资源

### sessionStorage

+ ==只能是字符串格式==
+ 在浏览器中保存，不会随HTTP请求发送到服务器
+ 仅在当前浏览器会话期间有效。一旦浏览器关闭，`sessionStorage`中的数据就会被清除。
+ 仅在同一标签页的同一个源（协议+域名+端口）内有效，不同标签页或窗口之间无法共享
+ 通常有更大的存储容量限制（例如，5MB）。

### localStorage

+ ==只能是字符串格式==
+ 存储位置：同样存储在浏览器中，不随HTTP请求发送到服务器。
+ 生命周期：`localStorage`的数据没有过期时间，除非用户主动清除或通过代码删除，否则数据会一直保留。
+ 作用域：在同一个源（协议+域名+端口）下的所有标签页和窗口中共享。
+ 容量：与`sessionStorage`类似，有较大的存储容量限制。
+ 使用场景：适用于需要长期保存的用户设置、应用状态等。

注：可以通过序列化和反序列化来存储任意类型的数据

### uuid全球唯一id(universal unique identity)

sessionId最好用uuid，保证唯一性

